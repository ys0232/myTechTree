海量对象存储项目总结
1.对象存储特点
数据作为单独的对象进行存储;
数据存在于平面空间内;
应用通过唯一标识符来识别每个单独的数据对象;
对象存储面向具体的应用，而非用户，应用利用对象存储系统提供的API访问对象。

2.ceph与openstack swift比较
ceph采用c/c++编写，swift使用python编写。
ceph采用强一致性设计，在写入文件后，需要保证存储系统中的每个副本都完成更新，才可以进行读操作。
而swift采用最终一致性设计，在写入文件后，不必等到所有副本都完成更新，Swift针对的是读写都比较频繁的场景，所以采用了比较折中的策略，即写操作需要满足至少一半以上成功W>N/2，再保证读操作与写操作的副本集合至少产生一个交集，即R+W>N。在一定的时间限制内，对所有副本进行更新。swift牺牲一定的一致性用于提高读取速度，因此swift的读写效率要高于ceph。
ceph和swift都采用去中心化、全对称架构，所以不存在单点故障。

3.分布式领域的CAP理论
Consistency(一致性)，数据一致更新，所有数据变动都是同步的
Availability（可用性），好的响应时间
Partition tolerance(分区容错性)分区通信的可靠性
三者不可能同时成立。可以读写文件举例。
若要保持强一致性，在写入文件时需要锁住所有文件，此时可用性被破坏。

4.分布式哈希表（DHT）
分布式哈希表是一种分布式存储方法。这种网络不需要中心节点服务器，而是每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现整个DHT网络的寻址和存储。DHT网络还在与关键字最接近的节点上复制冗余信息，避免了单一节点失效问题。
判断哈希算法好坏的标准：
平衡性：副本分布均匀。
单调性：在增加存储单元不会将已分配的内容映射到旧的存储单元中。即不会因为增加存储单元造成已分配的内容不符合映射规则。即节点变更不会改变网络的映射关系。
分散性：保证冗余的副本分布在不同的存储单元上。
负载均衡：保证每个存储单元的负载量相差不大。

一致性哈希算法：
环形hash空间
1.按照常用的hash算法将对应的key哈希到一个具有2的32次方的桶空间中。可以将其想象成一个环。
2.把数据通过一定的hash算法处理后映射到环上。
现在将object1、object2、object3、object4四个对象通过特定的哈希函数计算出对应的key值，然后散列到环上。
3.将机器通过hash算法映射到环上
在采用一致性哈希算法的分布式集群中，在新机器加入时，通过使用与对象存储一样的hash算法，将机器也映射到环上，然后按顺时针方向计算，将hash算法得到对应的key值，映射到环中。
在这样的部署环境中，hash环是不会变更的，因此，通过计算对象的hash值就能很快定位到对应的机器上，这样就能找到对象真正的存储位置了。

通过对节点的添加/删除的分析，一致性哈希算法在保持了单调性的同时，还使数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减少了服务器的压力。

但是，此时的一致性哈希算法并不能保证平衡性，当某节点被删除时，会将该节点上的所有数据都迁移到顺时针方向，离它最近的节点上，此时这个最近节点比其他节点的负载多了一倍。这是十分不平衡的。

为了尽可能满足平衡性，需要引入虚拟节点。
虚拟节点实际上是实际机器在hash空间上的冗余，一个实际物理机器对应了若干个虚拟节点。

4.分级存储
分级存储是将数据采取不同的存储方式分别存储在不同性能的存储设备上，减少非重要性数据在一级磁盘所占用的空间，从而加速整个系统的存储性能。

经常访问的热数据放在读取速度较快的磁盘上，不常访问的数据放在读取速度较慢的磁盘上。
使用LVMcache技术，SSD作缓存。
LVM是Logical Volume Manager(逻辑卷管理)，它是linux环境下对磁盘分区进行管理的一种机制。
普通的磁盘管理方式在逻辑分区划分好了之后无法改变逻辑分区的大小，当一个逻辑分区放不下某个文件时，这个文件因为受到上层文件系统的限制，也不能跨越多个分区存放，所以也不能同时放到别的磁盘上。当某个分区空间耗尽时，解决方法通常是符号链接，或者使用调整分区大小的工具，但这只是暂时的解决办法。使用LVM，用户可以在无需停机的情况下方便地调整各个分区大小。
LVM是建立在硬盘和分区之间的逻辑层，用于提高磁盘分区管理的灵活性。

和非LVM系统将包含分区信息的元数据保存在位于分区起始位置的分区表中一样，逻辑卷以及卷组相关的元数据也是保存在位于物理卷起始处的VGDA（卷组描述符区域）中，VGDA包括以下内容：PV描述符、VG描述符、LV描述符和一些PE（物理块）描述符。
系统启动LVM时激活VG（卷组），并将VGDA（卷组描述符区域）加载至内存，来识别LV（逻辑卷）的实际物理存储位。当系统进行I/O操作时，就会根据VGDA建立的映射机制来访问实际物理位置。

5.分布式系统的一致性协议
（1）2PC/3PC提交（为了保证事物的ACID）
ACID：数据库事务正确执行的四个基本要素：原子性、一致性、隔离性和持久性。
====================
2PC是二段提交（RDBMS就是这种机制，保证强一致性）。3PC是三段提交。
2PC提交---1阶段：提交事务请求（投票阶段）
2PC提交---2阶段：执行事务的提交（commit、rollback的情况）
====================
3PC提交---阶段1：是否提交
3PC提交---阶段2：预先提交
3PC提交---阶段3：提交（commit、rollback）
相当于将2PC的第一步拆解成了两步进行操作；只有在2PC和3PC的最后一步时，才进行rollback。
（2）CAP理论（分布式系统遵循的理论）
P：Partition tolerance (分区容错性)
A：Availability(可用性)
C：Consistency(一致性)
CA（放弃P）：将所有的数据放在一个节点上，满足可用性和一致性。代表有RDBMS（关系数据库管理系统）
AP（放弃C）：使用弱一致性代替强一致性。代表有DynamoDB Cassandra
CP（放弃A）：一旦系统出现故障，受影响的服务器需要等待一段时间，在恢复期间无法对外提供服务。
代表有：MongoDB Hbase Redis
（3）BASE理论
大致可分为：基本可用（bascially available）、软状态（Soft state）和最终一致性（Eventually consistent）.
基本可用：在分布式系统中，允许损失部分可用性；比如服务降级、页面降级等；
软状态：允许分布式中出现中间状态，而且中间状态不影响分布式系统的可用性；
最终一致性：经过一段时间数据达成一致。
（4）Paxos算法
Paxos：多数派决议（最终解决一致性）
=========================
三种角色：
proposer:提交者（议案提交者）；提交议案，提交批准议案；
acceptor:接受者（议案接受者）；接受议案或者驳回议案，返回proposer相关内容；
learning：学习者；如果产生议案就学习议案。
=========================
设定1：如果acceptor没有接受议案，那么他必须接受第一个议案。
设定2：每个议案必须有一个编号，并且编号只能增长，不能重复。越往后越大。
设定3：接受编号大的议案，如果小于之前接受议案编号，那么不接受。
设定4：议案有2种（提交的议案和批准的议案）
=========================
Prepare阶段（决议提交）
1）proposer希望议案V。首先发出prepare请求至大多数acceptor。prepare请求内容为序列号k。
2）acceptor收到prepare请求为编号k后，检查自己手里是否处理过prepare请求。
3）如果acceptor没有接受过任何prepare请求，那么用ok来回复proposer，代表acceptor必须接受收到的第一个议案。（设定1）
4）否则，如果acceptor之前接受过任何prepare请求（如：maxN），那么比较议案编号，如果k<maxN，则用reject或者error回复proposer。
5）如果k>=maxN，那么检查之前是否有批准的议案，如果没有则用ok来回复proposer，并记录k;若有批准的议案，则回复议案编号和议案内容（如：<acceptN,acceptV>,acceptN为批准的议案编号，acceptV为批准的议案内容）
Accept阶段（批准阶段）
1）proposer收到过半acceptor发来的回复，回复都是ok，且没有附带任何批准过的议案编号和议案内容。那么proposer继续提交批准请求，不过此时会连议案编号k和议案内容v一起提交（<k,v>这种形式的数据）
2）proposer收到过半acceptor发来的回复，回复都是ok，且附带批准过的议案编号和议案内容（<pok,议案编号，议案内容>）。那么proposer找到所有回复中超过半数的那个（假设为<pok,acceptNx,acceptVx>）作为提交批准请求（请求为<k,acceptVx>）发送给acceptor。
3）proposer没有收到过半acceptor发来的回复，则修改议案编号k为kx，并将编号重新发送给acceptor（重复prepare请求阶段）。
4）acceptor收到proposer发来的accept请求，如果编号k<maxN则不回应或者reject。
5）acceptor收到proposer发来的accept请求，如果编号k>=maxN则批准该议案。并设置手中批准的议案为<k,接受议案的编号，接受议案的内容>，回复proposer。
6）经过一段时间proposer对比手中收到的accept回复，如果超过半数，则结束流程（代表议案被批准），同时通知learner可以学习议案。
7）经过一段时间proposer对比手中受到的accept回复，如果未超过半数，则修改议案编号重新进入prepare阶段。
===================
（5）拜占庭将军问题
拜占庭军队有许多分支，驻扎在敌人城外，每一分支由各自的将军指挥。将军靠通讯员进行通讯。在观察敌人后，忠诚的将军必须制定一个统一的行动计划---进攻或者撤退。然而，这些将军中有叛徒，他们不希望忠诚的将军达成一致，因而影响同一行动计划的制定与传播。
问题描述：
1）11位将军进攻城池
2）同时进攻（议案、决议）、同时撤退（议案、决议）
3）不管撤退还是进攻，必须半数的将军统一意见才可以执行
4）将军里有叛徒会干扰决议生成
角色：
proposer:参谋1、参谋2
acceptor:将军1、将军2、将军3（决策者）
===================
先后提议的场景：
1）参谋1发起提议，派通信员带信给3个将军，内容为编号1；
2）3个将军收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信员带信回去，内容为ok;
3）参谋1收到至少2个将军的回复，再次派通信员带信给3个将军，内容为（编号1,进攻时间1）；
4）3个将军收到参谋1的时间，把（编号1,进攻时间1）保存下来，避免遗忘；同时让通信员带信回去，内容为accepted；
5）参谋1收到至少2个将军的（accepted）内容，确认进攻时间已经被大家接受；
6）参谋2发起提议，派通信员带信给3个将军，内容为编号2；
7）3个将军收到参谋2的提议，由于编号2比编号1大，因此把编号2保存下来避免遗忘；又由于之前已经接受参谋1的提议，因此让通信员带信回去，内容为<编号1,进攻时间1>；
8）参谋2收到至少2个将军的回复，由于回复中带来了已接受的参谋1的提议内容，因此参谋2不再提出新的进攻时间，接受参谋1提出的时间。
===================
交叉场景：
1）参谋1发起提议，派通信员带信给3个将军，内容为编号1；
2）将军1、将军2收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信员带信回去，内容为ok;
3）负责通知将军3的通信员被抓，因此将军3没有收到参谋1的提议；
4）同时参谋2发起提议，派通信兵带信给3个将军，内容为编号2；
5）3个将军的情况如下：a)将军2和将军3收到参谋2的提议，将军2、将军3把编号2记录下来，如果有其他参谋提出编号更小的提议，将被拒绝；同时让通信员带信回去，内容为（ok）；b) 负责通知将军1的通信员被抓，因此将军1没有收到参谋2的提议；
6）参谋1至少收到2个将军回复，再次派通信员带信给有答复的2个将军，内容为（编号1,进攻时间1）；
7）2个将军情况如下：a）将军1收到了（编号1,进攻时间1），和自己保存的编号相同，因此把（编号1,进攻时间1）保存下来；同时让通信员带信回去，内容为（accepted）；b）将军2收到（编号1,进攻时间1），由于编号1小于保存的编号2,因此让通信员带信回去，内容为（rejected，编号2）。
8）参谋2至少收到2个将军回复，再次派通信员带信给有答复的2个将军，内容为（编号2,进攻时间2）；
9）将军2和将军3收到（编号2,进攻时间2），和自己保存的编号相同，因此把（编号2,进攻时间2）保存下来，同时让通信员带信回去，内容为（accepted）；
10）参谋2收到至少2个将军的(accepted)内容，确认进攻时间已经被多数派接受；
11）参谋1只收到了1个将军的（accepted）内容，同时收到一个（rejected,编号2）；参谋1重新让通信员带信给3个将军，内容为（编号3）；
12）3个将军的情况如下：a）将军1收到参谋1的提议，由于编号3比编号1大，因此把编号3保存下来；由于将军1已经接受参谋1前一次的提议，因此让通信员带信回去，内容为（编号1,进攻时间1）；b）将军2收到参谋1的提议，由于编号3比编号2大，因此把编号3保存下来，由于将军2以及接受参谋2的提议，因此让通信员带信回去，内容为（编号2,进攻时间2）；c）负责给将军3带信的通信员被抓，因此将军3没有收到参谋1的提议；
13）参谋1收到至少两个将军的回复，比较两个回复的编号大小，选中编号大的对应的进攻时间作为最新提议；参谋1再次派通信员带信给有答复的两个将军，内容为（编号3,进攻时间2）；
14）将军1和将军2收到了（编号3,进攻时间2），和自己保存的标号相同，因此保存（编号3,进攻时间2），同时让通信员带信回去，内容为（accepted）；
15）参谋1收到了至少2个将军的（accepted）内容，确认进攻时间已经被多数派接受。



